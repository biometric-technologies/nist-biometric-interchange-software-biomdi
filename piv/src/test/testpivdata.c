/*
* This software was developed at the National Institute of Standards and
* Technology (NIST) by employees of the Federal Government in the course
* of their official duties. Pursuant to title 17 Section 105 of the
* United States Code, this software is not subject to copyright protection
* and is in the public domain. NIST assumes no responsibility  whatsoever for
* its use by other parties, and makes no guarantees, expressed or implied,
* about its quality, reliability, or any other characteristic.
*/

/*
 * Test some of the functions in the PIV library.
 */

#define _XOPEN_SOURCE   1

#include <sys/queue.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <termios.h>
#include <unistd.h>

#include <biomdimacro.h>
#include <fmr.h>

#include <piv.h>
#include <pivcard.h>
#include <pivdata.h>

static unsigned char FMR_Example[] = {
    0x46, 0x4d, 0x52, 0x00, 0x20, 0x32, 0x30, 0x00, 0x01, 0x57, 0x00, 0x42,
    0x00, 0x11, 0x00, 0xb5, 0x02, 0x00, 0x02, 0x00, 0x00, 0xc5, 0x00, 0xc5,
    0x02, 0x00, 0x07, 0x00, 0x5a, 0x1b, 0x40, 0x64, 0x00, 0x0e, 0x38, 0x5a,
    0x40, 0xa4, 0x00, 0x11, 0x2b, 0x50, 0x80, 0x37, 0x00, 0x12, 0x0b, 0x5a,
    0x80, 0x4a, 0x00, 0x16, 0x26, 0x3c, 0x40, 0x70, 0x00, 0x16, 0x2d, 0x50,
    0x80, 0x2a, 0x00, 0x1f, 0x16, 0x5a, 0x80, 0x93, 0x00, 0x23, 0x1a, 0x5a,
    0x40, 0x58, 0x00, 0x26, 0x53, 0x28, 0x80, 0x2b, 0x00, 0x2a, 0x02, 0x50,
    0x40, 0x38, 0x00, 0x30, 0x11, 0x46, 0x40, 0x84, 0x00, 0x31, 0x24, 0x5a,
    0x80, 0x47, 0x00, 0x32, 0x2f, 0x50, 0x00, 0x5f, 0x00, 0x33, 0x29, 0x5a,
    0x40, 0x70, 0x00, 0x35, 0x3d, 0x32, 0x80, 0x87, 0x00, 0x3a, 0x10, 0x50,
    0x00, 0x29, 0x00, 0x3c, 0x1e, 0x46, 0x80, 0x43, 0x00, 0x3e, 0x49, 0x5a,
    0x40, 0x5b, 0x00, 0x3f, 0x3d, 0x50, 0x40, 0x70, 0x00, 0x41, 0x11, 0x3c,
    0x40, 0x35, 0x00, 0x47, 0x17, 0x5a, 0x80, 0x68, 0x00, 0x4a, 0x06, 0x50,
    0x40, 0x4b, 0x00, 0x4f, 0x0b, 0x5a, 0x80, 0x30, 0x00, 0x50, 0x2e, 0x5a,
    0x40, 0x82, 0x00, 0x59, 0x17, 0x50, 0x80, 0x3f, 0x00, 0x5f, 0x3f, 0x50,
    0x40, 0x2f, 0x00, 0x6c, 0x52, 0x5a, 0x80, 0x7e, 0x00, 0x73, 0x56, 0x1e,
    0x00, 0x00, 0x02, 0x00, 0x46, 0x16, 0x40, 0x28, 0x00, 0x5d, 0x00, 0x5a,
    0x80, 0x74, 0x00, 0x64, 0x00, 0x50, 0x40, 0x52, 0x00, 0x5f, 0x06, 0x46,
    0x80, 0x8c, 0x00, 0x71, 0x08, 0x46, 0x40, 0x7a, 0x00, 0x87, 0x09, 0x50,
    0x80, 0x37, 0x00, 0x48, 0x0b, 0x32, 0x40, 0x5e, 0x00, 0x4a, 0x0c, 0x3c,
    0x40, 0x9b, 0x00, 0x3e, 0x15, 0x50, 0x80, 0x2a, 0x00, 0x40, 0x1c, 0x46,
    0x40, 0x9b, 0x00, 0x55, 0x1e, 0x50, 0x80, 0x60, 0x00, 0xc0, 0x1f, 0x50,
    0x40, 0x72, 0x00, 0x56, 0x2b, 0x50, 0x80, 0x8e, 0x00, 0x5a, 0x2d, 0x46,
    0x40, 0x39, 0x00, 0x89, 0x32, 0x5a, 0x40, 0x83, 0x00, 0x4b, 0x37, 0x50,
    0x40, 0x2d, 0x00, 0x71, 0x3c, 0x50, 0x80, 0x6f, 0x00, 0xab, 0x41, 0x32,
    0x40, 0x5f, 0x00, 0x3e, 0x4b, 0x3c, 0x80, 0x3d, 0x00, 0x72, 0x64, 0x50,
    0x80, 0x8f, 0x00, 0x48, 0x7d, 0x50, 0x40, 0x3f, 0x00, 0x68, 0x96, 0x46,
    0x80, 0x7d, 0x00, 0x49, 0xaf, 0x28, 0x00, 0x0b, 0x00, 0x01, 0x00, 0x0b,
    0x01, 0x01, 0x14, 0x0c, 0x05, 0x07, 0x05
};
static unsigned int FMR_Example_len = 343;

static void
usage()
{
	fprintf(stderr, "Usage: testpivdata\n");
	exit (EXIT_FAILURE);
}

static void
testPINValidation()
{
	int i;
	int ret;
	unsigned char pin[PIV_PIN_LENGTH];

	/* Check some PINs */
	bcopy("1234", pin, PIV_PIN_LENGTH);
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(%s) returns %d.\n", pin, ret);

	bcopy("12345678", pin, PIV_PIN_LENGTH);
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(%s) returns %d.\n", pin, ret);

	bzero(pin, PIV_PIN_LENGTH);
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(%s) returns %d.\n", pin, ret);

	bzero(pin, PIV_PIN_LENGTH);
	pin[0] = '1';
	pin[1] = 0xff;
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(1ff) returns %d.\n", ret);

	bzero(pin, PIV_PIN_LENGTH);
	for (i = 0; i < PIV_PIN_LENGTH; i++)
		pin[i] = 0xff;
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(ffffffffffffffffffffffffffffffff) returns %d.\n", ret);

	bcopy("1234567", pin, PIV_PIN_LENGTH);
	pin[PIV_PIN_LENGTH - 1] = 0xff;
	ret = pivValidatePIN(pin);
	printf("pivValidatePIN(1234567ff) returns %d.\n", ret);
}

static void
testFMROps()
{
	FMR *fmr, *newfmr;
	FVMR **fvmrs;
	FMD **fmds;
	BDB bdb;
	int ret;
	uint8_t *databuf;
	int databuf_len;
	unsigned int c1, c2, i, j;
	struct piv_fmd *pfmd;

	INIT_BDB(&bdb, FMR_Example, FMR_Example_len);
	new_fmr(FMR_STD_ANSI, &fmr);
	scan_fmr(&bdb, fmr);
	c1 = get_fvmr_count(fmr);
	if (c1 != 2) {
		fprintf(stderr, "FMR doesn't have two views.\n");
		return;
	}
	fvmrs = malloc(2 * sizeof(FVMR *));
	get_fvmrs(fmr, fvmrs);
	databuf = malloc(PIV_MAX_OBJECT_SIZE);

	for (i = 1; i < 3; i++) {
		/* Test pivGetFingerMinutiae() */
		databuf_len = PIV_MAX_OBJECT_SIZE;
		ret = pivGetFingerMinutiae(i, FMR_Example, FMR_Example_len,
		    databuf, &databuf_len, &c1);
		printf("View %u of the example FMR has %u minutiae.\n", i, c1);
		c2 = get_fmd_count(fvmrs[i-1]);
		if (c2 != c1) {
			printf("Minutiae count from pivGetFingerMinutiae() "
			    "doesn't match count from FVMR %u in FMR record.\n",
			    i-1);
			continue;
		}
		fmds = malloc(c2 * sizeof(FMD *));
		get_fmds(fvmrs[i-1], fmds);
		/* Map the XYT struct over data returned above */
		pfmd = (struct piv_fmd *)databuf;
		for (j = 0; j < c2; j++) {
			if (pfmd->angle != fmds[j]->angle * 2)
				printf("Error: Angle mismatch.\n");
			pfmd++;
		}
		free(fmds);

		/* Test pivSubsetFingerMinutiaeRec() */
		databuf_len = PIV_MAX_OBJECT_SIZE;
		ret = pivSubsetFingerMinutiaeRec(i, FMR_Example,
		    FMR_Example_len, databuf, &databuf_len);
		INIT_BDB(&bdb, databuf, databuf_len);
		new_fmr(FMR_STD_ANSI, &newfmr);
		scan_fmr(&bdb, newfmr);
print_fmr(stdout, newfmr);
		free_fmr(newfmr);
	}
	free(fvmrs);
	free_fmr(fmr);
}

int
main(int argc, char *argv[])
{

	if (argc != 1)
		usage();

	testPINValidation();

	testFMROps();

	exit(EXIT_SUCCESS);
}
